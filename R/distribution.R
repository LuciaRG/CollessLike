#' @title Computes the percentile in the alpha-gamma distribution of the indices of the given tree
#' 
#' @description Computes the percentile in the alpha-gamma distribution of the indices (Colless-like, Sackin and Cophenetic) of the given tree. It also plots all the three distributions highlighting where are the indices of the given tree or it plots a percentile plot with the percentiles of the tree.
#' 
#' @param tree a single phylogenetic tree. It can be introduced as a string in the Newick format, as a "phylo" object (\code{ape} package) or as an "igraph" object (\code{igraph} package). 
#' @param alpha parametrer of the alpha-gamma model, between 0 and 1.
#' @param gamma parametrer of the alpha-gamma model, between 0 and alpha.
#' @param set.indices if \code{NULL}(default) the indices data is taken from stored data or from a new simulated data (See "Details"). If not, it must be a 3-column data.frame with the three balance indices (Colles-like, Sackin, Cophenetic). See \code{\link{indices.simulation}}.
#' @param new.simulation if \code{FALSE}(default) the indices data it could be from a data.frame introduced by the user or a data.frame from our database. If it is \code{TRUE}, a new indices data set is computed. See \code{\link{indices.simulation}}.
#' @param repetitions the number of trees to generate in case a new simulation is done.
#' @param legend.location location where the legend is going to be placed. See "Details".
#' @param cex expansion factor of the legend. See "Details".
#' @param percentile.plot if \code{TRUE} plots the percentile plot of the indices. If it is \code{FALSE}(default) , then a distribution plot is represented.
#' @param db.path by default is the actual working directory. It should be changed if the data base is going to be used and it is located in a different directory.
#'
#' @details Two plots are available: one with the acumulated percentiles of the indices (\code{percentile.plot=FALSE}), and the other with the distribution (\code{percentile.plot=TRUE}).
#' 
#' The stored data available has been calculated for a number of leaves between 3 and 50. For each of them, the parameters are set as \code{alpha} in \{0,0.1,0.2,...,1\} and \code{gamma} in \{0,0.1,0.2,...,\code{alpha}\}. If the introduced parameters are not in the list, a new computation is done with them and a new dataset of trees is generated, and computed its indices. The number of trees generated can be modified by the parameter \code{repetitions} (see \code{\link{indices.simulation}} for more information). This computation may take some time, therefore you can computate it separately with \code{\link{indices.simulation}}, save its value and then call this function  by setting it as the parameter \code{set.indices}.
#' 
#' The legend is placed with the \code{graphics} function \code{legend()}, so its location can be specified by setting \code{legend.position} to a single keyword from the list \code{"bottomright"}, \code{"bottom"}, \code{"bottomleft"}, \code{"left"}, \code{"topleft"}, \code{"top"}, \code{"topright"}, \code{"right"} and \code{"center"}. 
#' The expansion factor for the legend is controlled by the parameter \code{cex}, by default \code{cex=1}. See \code{\link[graphics]{legend}}.
#'
#' @return A numeric vector with the three percentiles.
#' 
#' @references  Chen, B., Ford, D., Winkel, M., A new family of Markov branching trees: the alpha-gamma model. \emph{Electr. J. Probab}. \bold{14} (2009), 400-430. MR2480547
#' 
#' A. Mir, F. Rossello, L.Rotger, A Colless-like balance index for multifurcating phylogenetic trees.
#' 
#' A. Mir, F. Rossello, L.Rotger, A new balance index for phylogenetic trees. Math. Biosc. 241 (2013).
#' 
#' M. J. Sackin, "Good" and  "bad" phenograms. Sys. Zool, 21 (1972), 225-226.
#' 
#' @seealso \code{\link[graphics]{legend}}, \code{\link{indices.simulation}}, \code{\link{balance.indices}}
#' 
#' @examples 
#' #If it is need, to specify the location of the database
#' #folder=".../CollesLikeDataBase/" 
#' ##If not,
#' folder=getwd()
#' ## Different ways to introduce the tree
#' #From a newick string
#' distribution("(1,2,3,4,5);",0.5,0.3,db.path=folder)
#' distribution("(1,(2,(3,(4,5))));",0.5,0.3,db.path=folder)
#' 
#' #From a phylo object
#' require(ape)
#' random.tree = rtree(5,rooted=TRUE)
#' distribution(random.tree,0.5,0.3,db.path=folder)
#' 
#' #An example of a tree generated by the alpha-gamma model (igraph object)
#' a.g.tree = a.g.model(5,0.5,0.3)
#' distribution(a.g.tree,0.5,0.3,db.path=folder)
#' 
#' ## Different indices data
#' # From our data base
#' distribution(a.g.tree,0.5,0.3,db.path=folder)
#' 
#' # From a data.frame generated by 'indices.simulation'
#' # ('Repetitions' set as 10 for a fast example)
#' indices.data = indices.simulation(5,0.5,0.3,10)
#' distribution(a.g.tree,0.5,0.3,set.indices=indices.data)
#' 
#' # Allow the function to do a new generation of data and compute their indices
#' distribution(a.g.tree,0.5,0.3,new.simulation=TRUE,repetitions=10)
#' # WARNING! it might take a long time, it depends on the parameters 
#' # 'n' (number of leaves) and 'repetition' (number of repetitions)
#' 
#' @importFrom ape read.tree
#' @importFrom igraph graph.edgelist degree
#' @importFrom graphics grid legend  lines mtext par plot points polygon text
#' @importFrom grDevices rgb 
#' @importFrom stats approxfun density  
#' @importFrom utils read.table 
#' 
#' @author Lucia Rotger
#' 
#' @export
distribution <-
  function(tree,alpha=NA,gamma=NA,set.indices=NULL,new.simulation=FALSE,repetitions=1000,
           legend.location="topright",cex=0.75,percentile.plot=FALSE,db.path=getwd() ){
    ## Class of object "tree"
    if(class(tree)=="character") 
      tree=read.tree(text = tree)
    if (class(tree)=="phylo") 
      tree=graph.edgelist(tree$edge, directed=TRUE)  
    if(class(tree)!="igraph")
      stop("Not an igraph object. Please introduce a newick string, an ape tree or an igraph tree.")
    n = sum(degree(tree,mode="out")==0)
    ## parameters alpha & gamma  
    if(new.simulation){
      print("This process might take a long time. If you want to save the indices 
            simulation, please run 'indices.simulation' directly and then call 'distribution' by setting
            the resulting table as the parameter 'set.indices'")
      warning("New simulation required")
      indices.list=indices.simulation(n,alpha,gamma,repetitions)
      txt = paste("Parameters: alpha=",alpha,", gamma=",gamma,"",sep="")
    }
    else{
      if(is.null(set.indices)){  
        if(alpha<gamma)
          stop("alpha < gamma")
        else{
          if((alpha>1)||(alpha<0)||(gamma>1)||(gamma<0))
            stop("alpha and gamma must been between 0 and 1")
          else{
            txt = paste("Parameters: n=",n,", alpha=",alpha,", gamma=",gamma,"",sep="")
            if(paste("n",n,sep="")%in%dir(db.path)){
              #print(TRUE)
              file = paste("CollessLikeDataBase_n",n,"_a",alpha*100,"_g",gamma*100,"_r5000.txt",sep="")
              folder = paste(db.path,"n",n,"/",sep="")
              if(file %in% dir(folder)){
                #print("READ") 
                indices.list=read.table(file=paste(folder,file,sep=""), header=TRUE)
              }
              else stop(paste("The file '",file,"' is not located at '",folder,"'",sep=""))
            }
            else stop(paste("The folder 'n",n,"' is not located at '",db.path,"'",sep=""))
            
            # if (n%in%3:50){ 
            #   warning("Aqui leera la tabla ya generada en el servidor")
            #   print("Aqui leera la tabla ya generada en el servidor")
            #   indices.list=read.table(file=paste("D:/Recerca/sep_2015/sep 2016/NuevosDatos/alpha-gamma/n",n,"/Datos_ford_n",n,"_a",alpha*100,"_g",gamma*100,"_r5000.txt",sep=""), header=TRUE)
            # } 
          }
        }
      }
      else{
        print("Indices Database introduced by user")
        txt=""
        indices.list = set.indices
      }
    }
    ########################################
    if(max(indices.list)>1){
      ## maximum
      max.cl = ( log(0+exp(1)) + log(2+exp(1)) )*(n-1)*(n-2)/4
      max.s = n*(n-1)/2 + n-1
      max.c = n*(n-1)*(n-2)/6
      indices.list[,1] = round(indices.list[,1]/max.cl,4)
      indices.list[,2] = round((indices.list[,2]-n)/(max.s-n),4)
      indices.list[,3] = round(indices.list[,3]/max.c,4)
    } 
    # densities
    d.cl= density(indices.list[,1]) ##
    d.s = density(indices.list[,2])   ##
    d.c = density(indices.list[,3])   ##
    xlim = range(c(0,1))
    ylim = range(c(0,d.cl$y,d.s$y,d.c$y))
    
    #tree
    tree.indices = balance.indices(tree)
    tree.indices = round(c(tree.indices[1]/max.cl,
                           (tree.indices[2]-n)/(max.s-n),
                           tree.indices[3]/max.c),4)
    
    f.cl=approxfun(d.cl$x,d.cl$y)
    f.s=approxfun(d.s$x,d.s$y)
    f.c=approxfun(d.c$x,d.c$y)
    tree.densities = round(c(f.cl(tree.indices[1]),f.s(tree.indices[2]),
                             f.c(tree.indices[3])),4)
    tree.densities[is.na(tree.densities)]=0 #NA => density=0
    #percentiles
    #percentiles = c(which(sort(indices.list[,1])>tree.indices[1])[1],
    #                which(sort(indices.list[,2])>tree.indices[2])[1],
    #                which(sort(indices.list[,3])>tree.indices[3])[1] )
    #percentiles = (percentiles-1) / dim(indices.list)[1]
    #percentiles[is.na(percentiles)]=1 #NA => idx>1
    #percentiles = round(percentiles,4)
    a.cl = cumsum(d.cl$y)
    a.cl=a.cl/max(a.cl) 
    a.s= cumsum(d.s$y)
    a.s= a.s/max(a.s) 
    a.c= cumsum(d.c$y)
    a.c= a.c/max(a.c)
    #tree index plots percs
    percs = c(a.cl[which(d.cl$x/max(d.cl$x)>tree.indices[1])[1]],
              + a.s[which(d.s$x/max(d.s$x)>tree.indices[2])[1]],
              + a.c[which(d.c$x/max(d.c$x)>tree.indices[3])[1]])
    percs[is.na(percs)]=1
    percs = round(percs,4)
    
    print(paste("Tree with n=",n," leaves",sep=""))
    print(paste("Colles-like: ",tree.indices[1],
                " (density:", tree.densities[1] ,"), Percentile:",
                percs[1] ,sep=""))
    print(paste("Sackin: ",tree.indices[2],
                " (density:", tree.densities[2] ,"), Percentile:",
                percs[2] ,sep=""))
    print(paste("Cophenetic: ",tree.indices[3],
                " (density:", tree.densities[3] ,"), Percentile:",
                percs[3],sep="")) 
    
    #plots
    par(xpd=FALSE)#Evita dibujar lineas fuera del plot
    
    if(!percentile.plot){
      plot(-1,-1 , xlab = "", ylab="Distribution of indices",
           xlim = xlim, ylim = ylim,xaxs = 'i',
           main = 'Distribution of indices', panel.first = grid() )
      
      polygon(d.cl, density = -1, col=rgb(1,0,0,0.2),border = "red",lwd = 1)
      polygon(d.s, density = -1, col=rgb(0,1,0,0.2),border = "green",lwd = 1)
      polygon(d.c, density = -1, col=rgb(0,0,1,0.2),border = "blue",lwd = 1)
      legend(legend.location,c("Colles-Like","Sackin","Cophenetic"),
             fill = c(rgb(1,0,0,0.2),rgb(0,1,0,0.2),rgb(0,0,1,0.2),
                      bty ='n',border = NA),cex=cex)
      
      #par(xpd=TRUE)#Evita dibujar lineas fuera del plot
      
      #tree plots
      lines(rep(tree.indices[1],2),c(0,tree.densities[1]),col=rgb(1,0,0),lwd =2)
      lines(rep(tree.indices[2],2),c(0,tree.densities[2]),col=rgb(0,1,0),lwd =2)
      lines(rep(tree.indices[3],2),c(0,tree.densities[3]),col=rgb(0,0,1),lwd =2)
      
      lines(xlim,c(0,0),lwd=2)
      
      points(tree.indices[1],tree.densities[1],pch=21,bg=rgb(1,0,0))
      points(tree.indices[2],tree.densities[2],pch=21,bg=rgb(0,1,0))
      points(tree.indices[3],tree.densities[3],pch=21,bg=rgb(0,0,1))
    }
    else{  
      plot(-1,-1 , xlab = "", ylab="Percentiles",
           xlim = xlim, ylim = c(0,1),xaxs = 'i',
           main = 'Percentile Plot', panel.first = grid() )   
      
      lines(d.cl$x/max(d.cl$x),a.cl, col=rgb(1,0,0))
      lines( d.s$x/max(d.s$x), a.s, col=rgb(0,1,0))
      lines( d.c$x/max(d.c$x), a.c, col=rgb(0,0,1))
      
      legend("topleft",c("Colles-Like","Sackin","Cophenetic"),
             fill = c(rgb(1,0,0,0.2),rgb(0,1,0,0.2),rgb(0,0,1,0.2),
                      bty ='n',border = NA),cex=cex)
      
      
      
      lines(rep(tree.indices[1],2),c(0,percs[1]),col=rgb(1,0,0),lwd =2)
      lines(rep(tree.indices[2],2),c(0,percs[2]),col=rgb(0,1,0),lwd =2)
      lines(rep(tree.indices[3],2),c(0,percs[3]),col=rgb(0,0,1),lwd =2)
      
      lines(xlim,c(0,0),lwd=1)
      
      points(tree.indices[1],percs[1],pch=21,bg=rgb(1,0,0))
      points(tree.indices[2],percs[2],pch=21,bg=rgb(0,1,0))
      points(tree.indices[3],percs[3],pch=21,bg=rgb(0,0,1))
      
    }
    mtext( txt , line = 0.5) 
    mtext("Normalized indices",line = 2.5,side = 1)
    mtext(bquote(paste("Percentiles are: ",P[CL],"=",.(percs[1]),
                       ", ", P[S],"=",.(percs[2]),", ",P[C],"=",.(percs[3]) )),
          line = 4,side = 1)
    return(percs)
  }
